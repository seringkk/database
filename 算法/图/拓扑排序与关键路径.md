### 1.拓扑排序

#### 介绍

​		之前介绍了两个有环图的应用（最小生成树、最短路径），现在来谈谈无环图的应用 (无环就是图中没有回路的意思)。

​		图 7-8-1 是一张电影制作流程图，我们可以看出，“制作电影” 这一个工程，包含了若干个活动。在这些活动之间，通常受到一些条件的约束，比如某些活动必须在另一些活动完成之后才能开始，就像不可能在人员到位驻进场地(v8)时，电影导演还没有确定(v2)，也不可能拍摄过程中，场地都没有。因此，这样的工程图，一定是无环的有向图。

![30](img\图进阶算法\30.png)



​		设 G = (V，E)是一个具有 n 个顶点的有向图，图中顶点表示活动，边表示活动之间的优先关系，这样的有向图称为用顶点表示活动的网，简称 **AOV 网**（Activity On Vertex Network）。V 中的顶点序列 v~1~，v~2~， ... ， v~n~ 满足若从顶点 v~i~ 到 v~j~ 有一条路径，则在顶点序列中顶点 v~i~ 必须在 v~j~ 之前。则我们称这样的顶点序列为一个拓扑序列。

​		图 7-8-1这样的 AOV 网的拓扑序列不止一条。如 v~0~ ~~~ ~16~，下标从0~16的序列就是其中一条。

​		所谓 **拓扑排序，就是对一个有向图构造拓扑序列的过程**。构造时会有两个结果，如果全部顶点都被输出，则说明该网是不存在环的AOV网；如果输出的顶点数不全，说明这个网存在环，不是AOV网。



#### 拓扑排序算法

​		对 AOV 网进行拓扑排序的基本思路是：**从 AOV网选择一个入度为 0 的顶点输出，然后删去此顶点，并删除一此顶点为尾的边，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止**。

​		由于拓扑排序过程中需要删除顶点，显然用邻接表更加方便。因此我们需要为AOV网建立一个邻接表。考虑到算法过程中始终要查找入度为0的顶点，我们原来的头节点中，增加一个入度域 in，如图，其中 in 就是该顶点的入度数。

![31](img\图进阶算法\31.png)



​		我们将下图的AOV网，转换成对应的的邻接表数据结构。

![32](img\图进阶算法\32.png)



![33](img\图进阶算法\33.png)



​		在算法中，还需要辅助的数据结构——栈，用来存储过程中入度为 0 的顶点，目的是为了避免每次查找时都要去遍历顶点表（这样做是很费时且没必要的）找有没有入度为 0 的顶点。

​		现在模拟一些过程。

```c
![34](C:\Users\TF\Desktop\算法\图\img\图进阶算法\34.png)// 拓扑排序, 若GL无回路, 则输出拓扑排序序列并返回1, 若有回路返回0
int TopologicalSort(AdjGraph* G)
{
    ArcNode *p;
    int i, k, gettop;
    int top = 0;       // 用于栈指针下标
    int count = 0;    // 用于统计输出顶点的个数
    int *stack;	      // 建栈将入度为0的顶点入栈
    stack = (int *)malloc(G->n * sizeof(int) );

    for(i = 0; i<G->n; i++)
        if(G->adjlist[i].in == 0) // 将入度为0的顶点入栈
            stack[++top]=i;
    // 栈顶不空循环
    while(top != 0) {
        gettop = stack[top];  --top; // 首元素出栈
        // 输出该顶点信息, 并计数
        printf("%d -> ",G->adjlist[gettop].data);  ++count;
        // 遍历该顶点的所有边结点
        p = G->adjlist[gettop].firstarc;
        while(p) {
            k = p->adjvex;
            if( !(-- G->adjlist[k].in) ) // 将该顶点的第一个邻接点的入度减1, 如果减1后为0, 则入栈
                stack[++top] = k;
            p = p->nextarc;
        }
    }
    printf("\n");
    if(count < G->n)
        return 0;
    else
        return 1;
}
```



1.首先用一个for循环将所有入度为 0 的顶点进栈。此时 stack = [0，1，3]。

![34](C:\Users\TF\Desktop\算法\图\img\图进阶算法\34.png)



2.之后栈不空就始终循环。第一个出栈的是 v~3~，我们打印它的信息（这里顶点存的信息很简单，就是它的编号），然后 count 加1。



3.接着对当前出栈的顶点的边链表进行遍历，顶点3连接顶点2、顶点13。将顶点3删除后，顶点2、13的入度自然要减1，再判断这两个顶点的入度是否为0，如果是 0 就要进栈了。（因为这里用栈的初衷，就是保存入度为0的顶点，不然每次找入度为0的点，都要遍历表，我们利用空间换取了时间）

![35](img\图进阶算法\35.png)



4.接下来操作类似，出栈顶点1，减少顶点8、4、2的入度后，发现顶点2入度为0，所以v~2~进栈。试想，如果没有在顶点表中加入 in 这个入度域，if( !(-- G->adjlist[k].in) 这条判断语句就必须是循环了，这又是空间换取时间。

![36](img\图进阶算法\36.png)



5.之后的处理方式都是一样的，下图展示了 v2 v6 v0 v4 v5 v8 的打印删除过程，剩下的几个点就不图示了

![37](img\图进阶算法\37.png)

![38](img\图进阶算法\38.png)



​		最终打印顺序为 3 -> 1 -> 2 -> 6 -> 0 -> 4 -> 5 -> 8 -> 7 -> 12 -> 9 -> 10 -> 13 -> 11。当然这个结果并不是唯一的一种拓扑排序方案。

​		分析整个算法，对于一个具有 n 顶点，e 条边的 AOV网来说，将入度为 0 的顶点入栈的时间复杂度为 O(n)，之后的 while 循环，每个顶点进一次栈，出一次栈，入度减1的操作执行了 e 次，所以整个算法的时间复杂度是 O(n + e)。



##### 完整代码

​		"MatGraph.cpp"  和  "AdjGraph.cpp"在  "数据结构" 一栏已经学过[数据结构/图的遍历代码](https://github.com/kyrian330/Data-Structure-Algorithm/tree/main/数据结构/图/Code/图的遍历代码)，复制之后修改一些内容即可，相信这些基础对我们这些聪明的coder来说不是问题吧。

```c
#include <stdio.h>
#include <malloc.h>
#include "MatGraph.cpp"
#include "AdjGraph.cpp"

// 邻接矩阵 转换成 邻接表
void MatToAdj(MatGraph g, AdjGraph *&G) {
    int i, j;
    ArcNode *p;
    G = (AdjGraph *)malloc(sizeof(AdjGraph));
    for (i=0; i<g.n; i++) {    // 邻接表中所有头结点的指针域置初值
        G->adjlist[i].in = 0;   // 入度起始都是0
        G->adjlist[i].data = i;  // 顶点信息就设置为顶点下标
        G->adjlist[i].firstarc = NULL;
    }
    for (i=0; i<g.n; i++)  // 检查邻接矩阵中每个元素
        for (j=0; j<=g.n; j++)
            if (g.edges[i][j]!=0 && g.edges[i][j]!=INF) {  // 有一条边
                p=(ArcNode *)malloc(sizeof(ArcNode));    // 创建结点p
                p->adjvex = j;
                p->weight = g.edges[i][j];
                p->nextarc = G->adjlist[i].firstarc;   // 头插法插入p
                G->adjlist[i].firstarc = p;
                G->adjlist[j].in++;    // 该顶点的入度 +1
            }
    G->n=g.n; G->e=g.e;	 // 置顶点数和边数
}


// 拓扑排序, 若GL无回路, 则输出拓扑排序序列并返回1, 若有回路返回0
int TopologicalSort(AdjGraph* G)
{
    ArcNode *p;
    int i, k, gettop;
    int top = 0;
    int count = 0;
    int *stack;
    stack = (int *)malloc(G->n * sizeof(int) );

    for(i = 0; i<G->n; i++)
        if(G->adjlist[i].in == 0)
            stack[++top]=i;
    while(top != 0) {
        gettop = stack[top];  --top;
        printf("%d -> ",G->adjlist[gettop].data);  ++count;
        p = G->adjlist[gettop].firstarc;
        while(p) {
            k = p->adjvex;
            if( !(-- G->adjlist[k].in) )
                stack[++top] = k;
            p = p->nextarc;
        }
    }
    printf("\n");
    if(count < G->n)
        return 0;
    else
        return 1;
}



int main()
{
    AdjGraph *G;
    MatGraph g;
    int n, e;
    int u, v, w;
    printf("输入:\n");
    scanf("%d %d", &n, &e);
    InitMat(g, n, e);    // 初始化
    // 插入边
    for (int i=0; i<e; i++) {
        scanf("%d %d %d", &u, &v, &w);
        InsertEdge(g, u, v, w);
    }
	printf("输出:\n");
    printf("图G的邻接矩阵:\n");  DispMat(g);
    MatToAdj(g, G);
    printf("图G的邻接表:\n");  DispAdj(G);

    // 求度
    printf("图G中所有顶点的入度:\n");
    printf("  顶点\t度\n");
    for (int i=0; i<G->n; i++)
        printf("   %d\t%d\n",i,Degree(G,i));

    int result=TopologicalSort(G);
    printf("result:%d",result);
    
    DestroyMat(g);
    DestroyAdj(G);
}
```

**完整的项目在**  [算法/图/Code/拓扑排序](https://github.com/kyrian330/Data-Structure-Algorithm/tree/main/算法/图/Code/拓扑排序)



- 结果

```c
输入:
14 20
0 4 1
0 5 1
0 11 1
1 2 1
1 4 1
1 8 1
2 5 1
2 6 1
2 9 1
3 2 1
3 13 1
4 7 1
5 8 1
5 12 1
6 5 1
8 7 1
9 10 1
9 11 1
10 13 1
12 9 1
输出:
图G的邻接矩阵:
   0 INF INF INF   1   1 INF INF INF INF INF   1 INF INF
 INF   0   1 INF   1 INF INF INF   1 INF INF INF INF INF
 INF INF   0 INF INF   1   1 INF INF   1 INF INF INF INF
 INF INF   1   0 INF INF INF INF INF INF INF INF INF   1
 INF INF INF INF   0 INF INF   1 INF INF INF INF INF INF
 INF INF INF INF INF   0 INF INF   1 INF INF INF   1 INF
 INF INF INF INF INF   1   0 INF INF INF INF INF INF INF
 INF INF INF INF INF INF INF   0 INF INF INF INF INF INF
 INF INF INF INF INF INF INF   1   0 INF INF INF INF INF
 INF INF INF INF INF INF INF INF INF   0   1   1 INF INF
 INF INF INF INF INF INF INF INF INF INF   0 INF INF   1
 INF INF INF INF INF INF INF INF INF INF INF   0 INF INF
 INF INF INF INF INF INF INF INF INF   1 INF INF   0 INF
 INF INF INF INF INF INF INF INF INF INF INF INF INF   0
图G的邻接表:
  [0] -> 11->5->4
  [1] -> 8->4->2
  [2] -> 9->6->5
  [3] -> 13->2
  [4] -> 7
  [5] -> 12->8
  [6] -> 5
  [7]
  [8] -> 7
  [9] -> 11->10
  [10] -> 13
  [11]
  [12] -> 9
  [13]
图G中所有顶点的入度:
  顶点  度
   0    0
   1    0
   2    2
   3    0
   4    2
   5    3
   6    1
   7    2
   8    2
   9    2
   10   1
   11   2
   12   1
   13   2
3 -> 1 -> 2 -> 6 -> 0 -> 4 -> 5 -> 8 -> 7 -> 12 -> 9 -> 10 -> 13 -> 11 ->
result:1
```



#### 关键路径

