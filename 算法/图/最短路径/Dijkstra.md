### 一、Dijkstra算法

本节来学习一个点（源点）到其余各个顶点的最短距离，也叫做 “单元最短路径”。如求下图中的1号顶点到 2、3、4、5、6号顶点的最短距离。


![1](https://github.com/kyrian330/Data-Structure-Algorithm/blob/main/%E7%AE%97%E6%B3%95/%E5%9B%BE/img/%E5%9B%BE%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/1.png)

#### 思路

用二维数组e来存储顶点之间边的关系，初始值如下。

![2](https://github.com/kyrian330/Data-Structure-Algorithm/blob/main/%E7%AE%97%E6%B3%95/%E5%9B%BE/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/img/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/2.png)


还需要一个一维数组dis来存储1号顶点到其余各个顶点的初始路程，如下。(inf是infinity的缩写，表示无穷值)

|         | 1    | 2    | 3    | 4    | 5    | 6    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| **dis** | 0    | 1    | 12   | INF  | INF  | INF  |

我们将此时dis数组中的值称为最短路程的 “估计值”。

- 易知离1号最近的点是2号点，选择了2号后dis[2]就变成了 ”确定值“，即1号到2号最短的路程就是当前dis[2]值。(1号顶点离2号最近，且这个图所有的边都是**正数**，那么就不存在第三个中转点，使得1到2的路程缩短)。



- 选择了2号，接下来就看2号有哪些出边。可知有**2 -> 3**、**2 -> 4**。想想通过**2 -> 3**这条边能否让1到3的路程变短，也就是比较dis[3]和dis[2] + e[2] [3]的大小。(dis[2]表示1到2的路程，e[2] [3]表示**2 ->3**这条边，所以dis[2] + e[2] [3]表示先从1到2，在从2经过边 **2 -> 3**到达顶点3)



- 以知dis[2] + e[2] [3] < dis[3]，因此dis[3]要更新为 1 + 9 =10。这个过程有个专业术语叫**”松弛“**，1号到3号顶点的路程即dis[3]，通过2 -> 3这条边松弛成功。同理，通过**2 -> 4**（e[2] [4]）将dis[4]从INF松弛为4。（dis[2] + e[2] [4] => 1 + 3 = 4）



现在，dis数组更新为

|         | 1    | 2    | 3    | 4    | 5    | 6    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| **dis** | 0    | 1    | 10   | 4    | INF  | INF  |

- 继续在剩下的3、4、5、6顶点中，选出离1号顶点最近的**4号**顶点。此时，dis[4]变成 ”确定值“，对4的所有出边（4 -> 3、4 -> 5、4 -> 6）按刚才的方法进行松弛。

- 对4松弛结束后，数组更新为

|         | 1    | 2    | 3    | 4    | 5    | 6    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| **dis** | 0    | 1    | 8    | 4    | 13   | 19   |

......

对最后一个顶点松弛后，dis数组如下，这便是1号顶点到各个顶点的最短路程。

|         | 1    | 2    | 3    | 4    | 5    | 6    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| **dis** | 0    | 1    | 8    | 4    | 13   | 17   |



#### 完整代码

```c
/*
 * @描述: Dijkstra算法
 * @作者: 星队
 * @创建时间: 2022/10/29
 */

#include <stdio.h>

int main()
{
    int e[10][10],dis[10],book[10];
    int n,m,i,j,t1,t2,t3,u,v,min=0;
    int inf = 9999999;

    scanf("%d %d", &n, &m);  // 输入 顶点个数和 边的条数

    // 初始化, 从1开始索引
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= n; ++j)
            if (i== j)  e[i][j] = 0;
                else  e[i][j] = inf;

    // 读入边
    for (i = 1; i <= m; ++i) {
        scanf("%d %d %d", &t1, &t2, &t3);
        e[t1][t2] = t3;
    }

    // 初始化dis数组, 1号到其他顶点的初始路程
    for (i = 1; i <= n ; ++i)
        dis[i] = e[1][i];

    // 初始化标记数组
    for (i = 1; i <= n ; ++i)
        book[i] = 0;
    book[1] = 1;

    // Dijkstra算法
    for (i = 1; i <= n - 1; ++i) { // 减去自身这个顶点
        min = inf;    // 找到离 i点最近的顶点
        for (j = 1; j <= n ; ++j) {
            if (book[j] == 0 && dis[j] < min) {
                min = dis[j];
                u = j;
            }
        }

        book[u] = 1;
        for (v = 1; v <= n ; ++v) {  // 对顶点u进行松弛
            if (e[u][v] < inf) {  // u到v有边, 通行。
                if (dis[u] + e[u][v] < dis[v])
                    dis[v] = dis[u] + e[u][v];
            }
        }
    }

    // 输出
    for (i = 1; i <= n ; ++i)
        printf("%d ", dis[i]);

    return 0;
}
```

- 结果

```c
输入:
6 9
1 2 1
1 3 12
2 3 9
2 4 3
3 5 5
4 3 4
4 5 13
4 6 15
5 6 4
输出:
0 1 8 4 13 17
```




- 多源最短路径

求各个顶点间的最短路径，对每个顶点都使用 Dijkstra 算法就行。

```c
/*
 * @描述: Dijkstra算法, 多源最短路径
 * @作者: 星队
 * @创建时间: 2022/11/13 13:55
 */

#include <stdio.h>
int book[10];

void Init(int n) {
    while (n--)
        book[n] = 0;
}

int main()
{
    int e[10][10],dis[10];
    int n,m,i,j,t1,t2,t3,u,v,min=0;
    int inf = 9999999;

    scanf("%d %d", &n, &m);

    for (i = 1; i <= n; ++i)
        for (j = 1; j <= n; ++j)
            if (i== j)  e[i][j] = 0;
            else  e[i][j] = inf;

    // 读入边
    for (i = 1; i <= m; ++i) {
        scanf("%d %d %d", &t1, &t2, &t3);
        e[t1][t2] = t3;
    }

    for (int k = 1; k <=n ; k++) {
        // 初始化标记数组
        Init(n);
        // 初始化 dis数组
        for (i = 1; i <= n ; ++i)
            dis[i] = e[k][i];

        book[k] = 1;   // 标记顶点 k
        // Dijkstra算法
        for (i = 1; i <= n-1; ++i) {
            min = inf;
            for (j = 1; j <= n; ++j) {
                if (book[j] == 0 && dis[j] < min) {
                    min = dis[j];
                    u = j;
                }
            }

            book[u] = 1;
            for (v = 1; v <= n; ++v) {
                if (e[u][v] < inf) {
                    if (dis[u] + e[u][v] < dis[v])
                        dis[v] = dis[u] + e[u][v];
                }
            }
        }

        for (i = 1; i <= n; ++i) {
            if (dis[i]==9999999)
                printf("INF ");     // 有向图, 表示顶点间不互通
            else
                printf("%d ", dis[i]);
        }
        printf("\n");
    }
    return 0;
}
```

- 结果

```c
输入:
6 9
1 2 1
1 3 12
2 3 9
2 4 3
3 5 5
4 3 4
4 5 13
4 6 15
5 6 4
    
输出:
0 1 8 4 13 17
INF 0 7 3 12 16
INF INF 0 INF 5 9
INF INF 4 0 9 13
INF INF INF INF 0 4
INF INF INF INF INF 0
```

